import { ObservablePoint } from '@pixi/core';
import { Container } from '@pixi/display';
import { AnyText, PixiText } from './utils/helpers/text';
import { Button } from './Button';
import { Signal } from 'typed-signals';
import { FederatedPointerEvent } from '@pixi/events';
declare const states: readonly ["default", "hover", "pressed", "disabled"];
type State = typeof states[number];
type Pos = {
    x?: number;
    y?: number;
};
type PosList = {
    [K in State]?: Pos;
};
export type Offset = Pos & PosList;
type Views = {
    defaultView?: string | Container;
    hoverView?: string | Container;
    pressedView?: string | Container;
    disabledView?: string | Container;
    text?: AnyText;
    icon?: string | Container;
};
type ButtonViews = {
    default?: Container;
    hover?: Container;
    pressed?: Container;
    disabled?: Container;
    text?: PixiText;
    icon?: Container;
};
type AnimationData = {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    scale?: Pos;
};
type Animation = {
    props: AnimationData;
    duration?: number;
};
type StateAnimations = {
    [K in State]?: Animation;
};
export type ButtonOptions = Views & {
    padding?: number;
    scale?: number;
    anchor?: number;
    anchorX?: number;
    anchorY?: number;
    offset?: Offset;
    textOffset?: Offset;
    iconOffset?: Offset;
    animations?: StateAnimations;
};
/**
 * Button component with a lots of tweaks, to create a button fast.
 *
 *  By default text view and icon view are centered in the active view.
 *
 * If views are not the same size, offset property of the constructor
 * can be used to adjust the position of the text, icon and the views.
 * @example
 * const button = new FancyButton({
 *     defaultView: `button.png`,
 *     hoverView: `button_hover.png`,
 *     pressedView: `button_pressed.png`,
 *     text: new Text('Click me!'),
 *     animations: {
 *          hover: {
 *              props: {
 *                  scale: {
 *                      x: 1.1,
 *                      y: 1.1,
 *                  }
 *              },
 *              duration: 100,
 *          },
 *          pressed: {
 *              props: {
 *                  scale: {
 *                      x: 0.9,
 *                      y: 0.9,
 *                  }
 *              },
 *              duration: 100,
 *          }
 *      }
 * });
 *
 * button.onPress.connect(() => console.log('Button pressed!'));
 */
export declare class FancyButton extends Container {
    protected events: Button;
    protected animations: StateAnimations;
    protected originalInnerViewState: AnimationData;
    protected defaultDuration: number;
    /** Padding of the button text view. If button text does not fit active view + padding it will scale down to fit. */
    padding: number;
    /** Offset of the button state views. If state views have different sizes, this option can help adjust them. */
    offset: Offset & Pos;
    /** Offset of the text view. Can be set to any state of the button. */
    textOffset: Offset;
    /** Offset of the icon view. Can be set to any state of the button. */
    iconOffset: Offset;
    innerView: Container;
    protected _views: ButtonViews;
    /** State of the button. Possible valuers are: 'default', 'hover', 'pressed', 'disabled' */
    state: State;
    /** Anchor point of the button. */
    anchor: ObservablePoint;
    /** Event that is fired when the button is down. */
    onDown: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /**
     * Event that fired when a down event happened inside the button
     * and up event happened inside or outside of the button
     */
    onUp: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /**
     * Event that fired when mouse up event happens outside of the button
     * after the down event happened inside the button boundaries.
     */
    onUpOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that fired when the mouse is out of the view */
    onOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that is fired when the button is pressed. */
    onPress: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** Event that is fired when the mouse hovers the button. Fired only if device is not mobile.*/
    onHover: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /**
     * Turns a given container-based view into a button by adding all button events.
     * @param {object} options - Button options.
     * @param {Container} options.defaultView - Container-based view that is shown when non of the button events are active.
     * @param {Container} options.hoverView - Container-based view that is shown when the mouse hovers over the button.
     * @param {Container} options.pressedView - Container-based view, shown when the mouse press on the component.
     * @param {Container} options.disabledView - Container-based view shown when the button is disabled.
     * @param {Container} options.icon - Container-based view for the button icon.
     * @param {Text} options.text - Text-based view for the button text.
     * @param {number} options.padding - Padding of the button text and icon views.
     * If button text or icon does not fit active view + padding it will scale down to fit.
     * @param {Point} options.offset - Offset of the button state views.
     * @param {Point} options.textOffset - Offset of the text view.
     * @param {Point} options.iconOffset - Offset of the icon view.
     * @param {number} options.scale - Scale of the button. Scale will be applied to a main container,
     * when all animations scales will be applied to the inner view.
     * @param {number} options.anchor - Anchor point of the button.
     * @param {number} options.anchorX - Horizontal anchor point of the button.
     * @param {number} options.anchorY - Vertical anchor point of the button.
     * @param options.animations - Animations that will be played when the button state changes.
     */
    constructor({ defaultView, hoverView, pressedView, disabledView, text, padding, offset, textOffset, iconOffset, scale, anchor, anchorX, anchorY, icon, animations }: ButtonOptions);
    /**
     * Updates the text of the button and updates its scaling basing on the new size.
     * @param {string | number} text
     */
    set text(text: string | number | null);
    /** Returns the text string of the button text element. */
    get text(): string | undefined;
    /**
     * Setter, that prevents all button events from firing.
     * @param {boolean} enabled
     */
    set enabled(enabled: boolean);
    /** Getter that returns button state, that controls if button events are firing. */
    get enabled(): boolean;
    /**
     * Updates button state and shows the according views.
     *
     * Updates positions and offsets of the views.
     *
     * Plays animations if they are set.
     * @param {State} newState
     */
    setState(newState: State): void;
    /**
     *
     * Manage button text view.
     * @param {string | Text} text - can be a string, Text, BitmapText ot HTMLText (Container-based element).
     */
    protected createTextView(text: AnyText): void;
    /**
     * Manages views offsets if it's set.
     * @param view
     * @param state
     * @param offset
     */
    protected setOffset(view: Container, state: State, offset: Offset): void;
    /**
     * Returns active view for the state.
     * @param state
     */
    protected getStateView(state: State): Container | undefined;
    /**
     * Adjusts text view position and scale.
     * @param {State} state
     */
    protected adjustTextView(state: State): void;
    /**
     * Adjusts icon view position and scale.
     * @param {State} state
     */
    protected adjustIconView(state: State): void;
    /**
     * Reset views positions according to the button anchor setting.
     * We have to set the anchor position for each view individually, as each of them
     * can be a different type of view (container without anchor, sprite with anchor, etc)
     * we have to reset all anchors to 0,0 and then set the positions manually.
     */
    protected updateAnchor(): void;
    /**
     * Set button views according to the config.
     * If state view is not set (undefined), it will not be changed,
     * so if it was set before, it will remain the same.
     * If state view is set to null, it will be removed from the button.
     * If state view is set it will be updated or added to a button.
     * @param {Views} views
     */
    set views(views: Views);
    /** Creates all button events */
    protected addEvents(): void;
    /**
     * Starts animation for the current button state if configured.
     * @param {State} state
     */
    protected playAnimations(state: State): void;
    /**
     * Method called when the button pressed.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    down(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the button is up.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    up(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the up event happens outside of the button,
     * after the down event happened inside the button boundaries.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    upOut(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse leaves the button.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    out(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse press down the button.
     * To be overridden.
     * @param {FederatedPointerEvent} _e - event data
     */
    press(_e?: FederatedPointerEvent): void;
    /**
     * Method called when the mouse hovers the button.
     * To be overridden.
     * Fired only if device is not mobile.
     * @param {FederatedPointerEvent} _e - event data
     */
    hover(_e?: FederatedPointerEvent): void;
}
export {};
//# sourceMappingURL=FancyButton.d.ts.map